<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title> - Aphros的个人博客</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="" />
<meta property="og:description" content="最新提案 本章介绍一些尚未进入标准、但很有希望的最新提案。 do 表达式 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 { let t = f(); t" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/es6tutorial/proposals/" /><meta property="article:section" content="posts" />

<meta property="og:site_name" content="Aphros的博客" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="最新提案 本章介绍一些尚未进入标准、但很有希望的最新提案。 do 表达式 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 { let t = f(); t"/>
<meta name="application-name" content="Aphros的博客">
<meta name="apple-mobile-web-app-title" content="Aphros的博客"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://localhost:1313/posts/es6tutorial/proposals/" /><link rel="prev" href="http://localhost:1313/posts/es6tutorial/proxy/" /><link rel="next" href="http://localhost:1313/posts/es6tutorial/promise/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/localhost:1313\/posts\/es6tutorial\/proposals\/"
        },"genre": "posts","wordcount":  4413 ,
        "url": "http:\/\/localhost:1313\/posts\/es6tutorial\/proposals\/","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Aphros"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Aphros的个人博客">Aphros的博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Aphros的个人博客">Aphros的博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX"></h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Aphros</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="0001-01-01">0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;4413 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;9 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#do-表达式">do 表达式</a></li>
    <li><a href="#throw-表达式">throw 表达式</a></li>
    <li><a href="#函数的部分执行">函数的部分执行</a>
      <ul>
        <li><a href="#语法">语法</a></li>
        <li><a href="#注意点">注意点</a></li>
      </ul>
    </li>
    <li><a href="#管道运算符">管道运算符</a></li>
    <li><a href="#mathsignbit">Math.signbit()</a></li>
    <li><a href="#双冒号运算符">双冒号运算符</a></li>
    <li><a href="#realm-api">Realm API</a></li>
    <li><a href="#json-模块">JSON 模块</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="最新提案">最新提案</h1>
<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>
<h2 id="do-表达式">do 表达式</h2>
<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到<code>t</code>的值，因为块级作用域不返回值，除非<code>t</code>是全局变量。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-do-expressions" target="_blank" rel="noopener noreffer ">提案</a>，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上<code>do</code>，使它变为<code>do</code>表达式，然后就会返回内部最后执行的表达式的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">t</span> <span class="o">*</span> <span class="nx">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面代码中，变量<code>x</code>会得到整个块级作用域的返回值（<code>t * t + 1</code>）。</p>
<p><code>do</code>表达式的逻辑非常简单：封装的是什么，就会返回什么。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// 等同于 &lt;表达式&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">do</span> <span class="p">{</span> <span class="o">&lt;</span><span class="nx">表达式</span><span class="o">&gt;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于 &lt;语句&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">do</span> <span class="p">{</span> <span class="o">&lt;</span><span class="nx">语句</span><span class="o">&gt;</span> <span class="p">}</span>
</span></span></code></pre></div><p><code>do</code>表达式的好处是可以封装多个语句，让程序更加模块化，就像乐高积木那样一块块拼装起来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">())</span> <span class="p">{</span> <span class="nx">f</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">bar</span><span class="p">())</span> <span class="p">{</span> <span class="nx">g</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span> <span class="nx">h</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面代码的本质，就是根据函数<code>foo</code>的执行结果，调用不同的函数，将返回结果赋给变量<code>x</code>。使用<code>do</code>表达式，就将这个操作的意图表达得非常简洁清晰。而且，<code>do</code>块级作用域提供了单独的作用域，内部操作可以与全局作用域隔绝。</p>
<p>值得一提的是，<code>do</code>表达式在 JSX 语法中非常好用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="nx">nav</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">Home</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">loggedIn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;</span><span class="nx">LogoutButton</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;</span><span class="nx">LoginButton</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">&lt;</span><span class="err">/nav&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>上面代码中，如果不用<code>do</code>表达式，就只能用三元判断运算符（<code>?:</code>）。那样的话，一旦判断逻辑复杂，代码就会变得很不易读。</p>
<h2 id="throw-表达式">throw 表达式</h2>
<p>JavaScript 语法规定<code>throw</code>是一个命令，用来抛出错误，不能用于表达式之中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">());</span>
</span></span></code></pre></div><p>上面代码中，<code>console.log</code>的参数必须是一个表达式，如果是一个<code>throw</code>语句就会报错。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-throw-expressions" target="_blank" rel="noopener noreffer ">提案</a>，允许<code>throw</code>用于表达式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// 参数的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">save</span><span class="p">(</span><span class="nx">filename</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;Argument required&#34;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 箭头函数的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">lint</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">with</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;avoid using &#39;with&#39; statements.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">getEncoder</span><span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">encoder</span> <span class="o">=</span> <span class="nx">encoding</span> <span class="o">===</span> <span class="s2">&#34;utf8&#34;</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nx">UTF8Encoder</span><span class="p">()</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">encoding</span> <span class="o">===</span> <span class="s2">&#34;utf16le&#34;</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="nx">UTF16Encoder</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">encoding</span> <span class="o">===</span> <span class="s2">&#34;utf16be&#34;</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="nx">UTF16Encoder</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;Unsupported encoding&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 逻辑表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">Product</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">get</span> <span class="nx">id</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span> <span class="nx">id</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">_id</span> <span class="o">=</span> <span class="nx">value</span> <span class="o">||</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;Invalid value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，<code>throw</code>都出现在表达式里面。</p>
<p>语法上，<code>throw</code>表达式里面的<code>throw</code>不再是一个命令，而是一个运算符。为了避免与<code>throw</code>命令混淆，规定<code>throw</code>出现在行首，一律解释为<code>throw</code>语句，而不是<code>throw</code>表达式。</p>
<h2 id="函数的部分执行">函数的部分执行</h2>
<h3 id="语法">语法</h3>
<p>多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">add7</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，<code>add7</code>函数其实是<code>add</code>函数的一个特殊版本，通过将一个参数绑定为<code>7</code>，就可以从<code>add</code>得到<code>add7</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// bind 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">add7</span> <span class="o">=</span> <span class="nx">add</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 箭头函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">add7</span> <span class="o">=</span> <span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</span></span></code></pre></div><p>上面两种写法都有些冗余。其中，<code>bind</code>方法的局限更加明显，它必须提供<code>this</code>，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-partial-application" target="_blank" rel="noopener noreffer ">提案</a>，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">addOne</span> <span class="o">=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">?</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">maxGreaterThanZero</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">...);</span>
</span></span></code></pre></div><p>根据新提案，<code>?</code>是单个参数的占位符，<code>...</code>是多个参数的占位符。以下的形式都属于函数的部分执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="o">?</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(...,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="o">?</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">(...,</span> <span class="nx">x</span><span class="p">,</span> <span class="p">...)</span>
</span></span></code></pre></div><p><code>?</code>和<code>...</code>只能出现在函数的调用之中，并且会返回一个新函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">);</span>
</span></span></code></pre></div><p>函数的部分执行，也可以用于对象的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 4
</span></span></span></code></pre></div><h3 id="注意点">注意点</h3>
<p>函数的部分执行有一些特别注意的地方。</p>
<p>（1）函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 替换函数 f
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 3
</span></span></span></code></pre></div><p>上面代码中，定义了函数的部分执行以后，更换原函数会立即影响到新函数。</p>
<p>（2）如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 改变 a 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 11
</span></span></span></code></pre></div><p>上面代码中，预先提供的参数是变量<code>a</code>，那么每次调用函数<code>g</code>的时候，才会对<code>a</code>进行求值。</p>
<p>（3）如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// [2, 1]
</span></span></span></code></pre></div><p>上面代码中，函数<code>g</code>只有一个占位符，也就意味着它只能接受一个参数，多余的参数都会被忽略。</p>
<p>写成下面这样，多余的参数就没有问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="o">?</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// [2, 1, 3, 4];
</span></span></span></code></pre></div><p>（4）<code>...</code>只会被采集一次，如果函数的部分执行使用了多个<code>...</code>，那么每个<code>...</code>的值都将相同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(...,</span> <span class="mi">9</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// [1, 2, 3, 9, 1, 2, 3]
</span></span></span></code></pre></div><p>上面代码中，<code>g</code>定义了两个<code>...</code>占位符，真正执行的时候，它们的值是一样的。</p>
<h2 id="管道运算符">管道运算符</h2>
<p>Unix 操作系统有一个管道机制（pipeline），可以把前一个操作的值传给后一个操作。这个机制非常有用，使得简单的操作可以组合成为复杂的操作。许多语言都有管道的实现，现在有一个<a href="https://github.com/tc39/proposal-pipeline-operator" target="_blank" rel="noopener noreffer ">提案</a>，让 JavaScript 也拥有管道机制。</p>
<p>JavaScript 的管道是一个运算符，写作<code>|&gt;</code>。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">|&gt;</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span></code></pre></div><p>管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">doubleSay</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">str</span> <span class="o">+</span> <span class="s2">&#34;, &#34;</span> <span class="o">+</span> <span class="nx">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">capitalize</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">str</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">exclaim</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">str</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面是三个简单的函数。如果要嵌套执行，传统的写法和管道的写法分别如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// 传统的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">exclaim</span><span class="p">(</span><span class="nx">capitalize</span><span class="p">(</span><span class="nx">doubleSay</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;Hello, hello!&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 管道的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s1">&#39;hello&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="o">|&gt;</span> <span class="nx">doubleSay</span>
</span></span><span class="line"><span class="cl">  <span class="o">|&gt;</span> <span class="nx">capitalize</span>
</span></span><span class="line"><span class="cl">  <span class="o">|&gt;</span> <span class="nx">exclaim</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &#34;Hello, hello!&#34;
</span></span></span></code></pre></div><p>管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。如果是多参数函数，就必须进行柯里化，改成单参数的版本。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="kr">double</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">add</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">score</span><span class="o">:</span> <span class="mi">25</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">score</span>
</span></span><span class="line"><span class="cl">  <span class="o">|&gt;</span> <span class="kr">double</span>
</span></span><span class="line"><span class="cl">  <span class="o">|&gt;</span> <span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="nx">add</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="nx">_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 57
</span></span></span></code></pre></div><p>上面代码中，<code>add</code>函数需要两个参数。但是，管道运算符只能传入一个值，因此需要事先提供另一个参数，并将其改成单参数的箭头函数<code>_ =&gt; add(7, _)</code>。这个函数里面的下划线并没有特别的含义，可以用其他符号代替，使用下划线只是因为，它能够形象地表示这里是占位符。</p>
<p>管道运算符对于<code>await</code>函数也适用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">|&gt;</span> <span class="kr">await</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">await</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">userAge</span> <span class="o">=</span> <span class="nx">userId</span> <span class="o">|&gt;</span> <span class="kr">await</span> <span class="nx">fetchUserById</span> <span class="o">|&gt;</span> <span class="nx">getAgeFromUser</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">userAge</span> <span class="o">=</span> <span class="nx">getAgeFromUser</span><span class="p">(</span><span class="kr">await</span> <span class="nx">fetchUserById</span><span class="p">(</span><span class="nx">userId</span><span class="p">));</span>
</span></span></code></pre></div><h2 id="mathsignbit">Math.signbit()</h2>
<p>JavaScript 内部使用64位浮点数（国际标准 IEEE 754）表示数值。IEEE 754 规定，64位浮点数的第一位是符号位，<code>0</code>表示正数，<code>1</code>表示负数。所以会有两种零，<code>+0</code>是符号位为<code>0</code>时的零，<code>-0</code>是符号位为<code>1</code>时的零。实际编程中，判断一个值是<code>+0</code>还是<code>-0</code>非常麻烦，因为它们是相等的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span> <span class="c1">// true
</span></span></span></code></pre></div><p>ES6 新增的<code>Math.sign()</code>方法，只能用来判断数值的正负，对于判断数值的符号位用处不大。因为如果参数是<code>-0</code>，它会返回<code>-0</code>，还是不能直接知道符号位是<code>1</code>还是<code>0</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// -0
</span></span></span></code></pre></div><p>目前，有一个<a href="https://github.com/tc39/proposal-Math.signbit" target="_blank" rel="noopener noreffer ">提案</a>，引入了<code>Math.signbit()</code>方法判断一个数的符号位是否设置了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nb">Math</span><span class="p">.</span><span class="nx">signbit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">signbit</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">signbit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">signbit</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">//true
</span></span></span></code></pre></div><p>可以看到，该方法正确返回了<code>-0</code>的符号位是设置了的。</p>
<p>该方法的算法如下。</p>
<ul>
<li>如果参数是<code>NaN</code>，返回<code>false</code></li>
<li>如果参数是<code>-0</code>，返回<code>true</code></li>
<li>如果参数是负值，返回<code>true</code></li>
<li>其他情况返回<code>false</code></li>
</ul>
<h2 id="双冒号运算符">双冒号运算符</h2>
<p>箭头函数可以绑定<code>this</code>对象，大大减少了显式绑定<code>this</code>对象的写法（<code>call()</code>、<code>apply()</code>、<code>bind()</code>）。但是，箭头函数并不适用于所有场合，所以现在有一个<a href="https://github.com/zenparsing/es-function-bind" target="_blank" rel="noopener noreffer ">提案</a>，提出了“函数绑定”（function bind）运算符，用来取代<code>call()</code>、<code>apply()</code>、<code>bind()</code>调用。</p>
<p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即<code>this</code>对象），绑定到右边的函数上面。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">foo</span><span class="o">::</span><span class="nx">bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bar</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="o">::</span><span class="nx">bar</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">bar</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">hasOwnProperty</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">obj</span><span class="o">::</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">method</span> <span class="o">=</span> <span class="nx">obj</span><span class="o">::</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">method</span> <span class="o">=</span> <span class="o">::</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">log</span> <span class="o">=</span> <span class="o">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
</span></span></code></pre></div><p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">takeWhile</span><span class="p">,</span> <span class="nx">forEach</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;iterlib&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">getPlayers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">character</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="nx">takeWhile</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">strength</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</span></span></code></pre></div><h2 id="realm-api">Realm API</h2>
<p><a href="https://github.com/tc39/proposal-realms" target="_blank" rel="noopener noreffer ">Realm API</a> 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。</p>
<p>以前，经常使用<code>&lt;iframe&gt;</code>作为沙箱。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">globalOne</span> <span class="o">=</span> <span class="nb">window</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;iframe&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">iframe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">globalTwo</span> <span class="o">=</span> <span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">;</span>
</span></span></code></pre></div><p>上面代码中，<code>&lt;iframe&gt;</code>的全局对象是独立的（<code>iframe.contentWindow</code>）。Realm API 可以取代这个功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">globalOne</span> <span class="o">=</span> <span class="nb">window</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">globalTwo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Realm</span><span class="p">().</span><span class="nx">global</span><span class="p">;</span>
</span></span></code></pre></div><p>上面代码中，<code>Realm API</code>单独提供了一个全局对象<code>new Realm().global</code>。</p>
<p>Realm API 提供一个<code>Realm()</code>构造函数，用来生成一个 Realm 对象。该对象的<code>global</code>属性指向一个新的顶层对象，这个顶层对象跟原始的顶层对象类似。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">globalOne</span> <span class="o">=</span> <span class="nb">window</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">globalTwo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Realm</span><span class="p">().</span><span class="nx">global</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">globalOne</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="s1">&#39;1 + 2&#39;</span><span class="p">)</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">globalTwo</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="s1">&#39;1 + 2&#39;</span><span class="p">)</span> <span class="c1">// 3
</span></span></span></code></pre></div><p>上面代码中，Realm 生成的顶层对象的<code>evaluate()</code>方法，可以运行代码。</p>
<p>下面的代码可以证明，Realm 顶层对象与原始顶层对象是两个对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a1</span> <span class="o">=</span> <span class="nx">globalOne</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="s1">&#39;[1,2,3]&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">globalTwo</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="s1">&#39;[1,2,3]&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">a1</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">a2</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a1</span> <span class="k">instanceof</span> <span class="nx">globalTwo</span><span class="p">.</span><span class="nb">Array</span><span class="p">;</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a2</span> <span class="k">instanceof</span> <span class="nx">globalOne</span><span class="p">.</span><span class="nb">Array</span><span class="p">;</span> <span class="c1">// false
</span></span></span></code></pre></div><p>上面代码中，Realm 沙箱里面的数组的原型对象，跟原始环境里面的数组是不一样的。</p>
<p>Realm 沙箱里面只能运行 ECMAScript 语法提供的 API，不能运行宿主环境提供的 API。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">globalTwo</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="s1">&#39;console.log(1)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// throw an error: console is undefined
</span></span></span></code></pre></div><p>上面代码中，Realm 沙箱里面没有<code>console</code>对象，导致报错。因为<code>console</code>不是语法标准，是宿主环境提供的。</p>
<p>如果要解决这个问题，可以使用下面的代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">globalTwo</span><span class="p">.</span><span class="nx">console</span> <span class="o">=</span> <span class="nx">globalOne</span><span class="p">.</span><span class="nx">console</span><span class="p">;</span>
</span></span></code></pre></div><p><code>Realm()</code>构造函数可以接受一个参数对象，该参数对象的<code>intrinsics</code>属性可以指定 Realm 沙箱继承原始顶层对象的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">r1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Realm</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">r1</span><span class="p">.</span><span class="nx">global</span> <span class="o">===</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">r1</span><span class="p">.</span><span class="nx">global</span><span class="p">.</span><span class="nx">JSON</span> <span class="o">===</span> <span class="nx">JSON</span><span class="p">;</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">r2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Realm</span><span class="p">({</span> <span class="nx">intrinsics</span><span class="o">:</span> <span class="s1">&#39;inherit&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">r2</span><span class="p">.</span><span class="nx">global</span> <span class="o">===</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">r2</span><span class="p">.</span><span class="nx">global</span><span class="p">.</span><span class="nx">JSON</span> <span class="o">===</span> <span class="nx">JSON</span><span class="p">;</span> <span class="c1">// true
</span></span></span></code></pre></div><p>上面代码中，正常情况下，沙箱的<code>JSON</code>方法不同于原始的<code>JSON</code>对象。但是，<code>Realm()</code>构造函数接受<code>{ intrinsics: 'inherit' }</code>作为参数以后，就会继承原始顶层对象的方法。</p>
<p>用户可以自己定义<code>Realm</code>的子类，用来定制自己的沙箱。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">FakeWindow</span> <span class="kr">extends</span> <span class="nx">Realm</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">global</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">global</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">global</span><span class="p">.</span><span class="nb">document</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FakeDocument</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">global</span><span class="p">.</span><span class="nx">alert</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">fakeAlert</span><span class="p">,</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码中，<code>FakeWindow</code>模拟了一个假的顶层对象<code>window</code>。</p>
<h2 id="json-模块">JSON 模块</h2>
<p>import 命令目前只能用于加载 ES 模块，现在有一个<a href="https://github.com/tc39/proposal-json-modules" target="_blank" rel="noopener noreffer ">提案</a>，允许加载 JSON 模块。</p>
<p>假定有一个 JSON 模块文件<code>config.json</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;appName&#34;</span><span class="o">:</span> <span class="s2">&#34;My App&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>目前，只能使用<code>fetch()</code>加载 JSON 模块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./config.json&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">json</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
</span></span></code></pre></div><p>import 命令能够直接加载 JSON 模块以后，就可以像下面这样写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">configData</span> <span class="nx">from</span> <span class="s1">&#39;./config.json&#39;</span> <span class="nx">assert</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s2">&#34;json&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">configData</span><span class="p">.</span><span class="nx">appName</span><span class="p">);</span>
</span></span></code></pre></div><p>上面示例中，整个 JSON 对象被导入为<code>configData</code>对象，然后就可以从该对象获取 JSON 数据。</p>
<p><code>import</code>命令导入 JSON 模块时，命令结尾的<code>assert {type: &quot;json&quot;}</code>不可缺少。这叫做导入断言，用来告诉 JavaScript 引擎，现在加载的是 JSON 模块。你可能会问，为什么不通过<code>.json</code>后缀名判断呢？因为浏览器的传统是不通过后缀名判断文件类型，标准委员会希望遵循这种做法，这样也可以避免一些安全问题。</p>
<p>导入断言是 JavaScript 导入其他格式模块的标准写法，JSON 模块将是第一个使用这种语法导入的模块。以后，还会支持导入 CSS 模块、HTML 模块等等。</p>
<p>动态加载模块的<code>import()</code>函数也支持加载 JSON 模块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./config.json&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">assert</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;json&#39;</span> <span class="p">}</span> <span class="p">})</span>
</span></span></code></pre></div><p>脚本加载 JSON 模块以后，还可以再用 export 命令输出。这时，可以将 export 和 import 结合成一个语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">export</span> <span class="p">{</span> <span class="nx">config</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./config.json&#39;</span> <span class="nx">assert</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;json&#39;</span> <span class="p">};</span>
</span></span></code></pre></div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 0001-01-01</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://localhost:1313/posts/es6tutorial/proposals/" data-title=""><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://localhost:1313/posts/es6tutorial/proposals/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="http://localhost:1313/posts/es6tutorial/proposals/" data-title=""><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://localhost:1313/posts/es6tutorial/proposals/" data-title=""><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://localhost:1313/posts/es6tutorial/proposals/" data-title=""><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/es6tutorial/proxy/" class="prev" rel="prev" title=""><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i></a>
            <a href="/posts/es6tutorial/promise/" class="next" rel="next" title=""><i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.118.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Aphros</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>

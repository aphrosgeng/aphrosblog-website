<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title> - Aphros的个人博客</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="" />
<meta property="og:description" content="TypeScript 的 interface 接口 简介 interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。 interface Person { firstName: string; lastName: string; age: number; } 上" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/typescript-tutorial/interface/" /><meta property="article:section" content="posts" />

<meta property="og:site_name" content="Aphros的博客" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="TypeScript 的 interface 接口 简介 interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。 interface Person { firstName: string; lastName: string; age: number; } 上"/>
<meta name="application-name" content="Aphros的博客">
<meta name="apple-mobile-web-app-title" content="Aphros的博客"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://localhost:1313/posts/typescript-tutorial/interface/" /><link rel="prev" href="http://localhost:1313/posts/typescript-tutorial/intro/" /><link rel="next" href="http://localhost:1313/posts/typescript-tutorial/generics/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/localhost:1313\/posts\/typescript-tutorial\/interface\/"
        },"genre": "posts","wordcount":  4975 ,
        "url": "http:\/\/localhost:1313\/posts\/typescript-tutorial\/interface\/","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Aphros"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Aphros的个人博客">Aphros的博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Aphros的个人博客">Aphros的博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX"></h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Aphros</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="0001-01-01">0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;4975 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;10 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#interface-的继承">interface 的继承</a>
      <ul>
        <li><a href="#interface-继承-interface">interface 继承 interface</a></li>
        <li><a href="#interface-继承-type">interface 继承 type</a></li>
        <li><a href="#interface-继承-class">interface 继承 class</a></li>
      </ul>
    </li>
    <li><a href="#接口合并">接口合并</a></li>
    <li><a href="#interface-与-type-的异同">interface 与 type 的异同</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="typescript-的-interface-接口">TypeScript 的 interface 接口</h1>
<h2 id="简介">简介</h2>
<p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">firstName</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lastName</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">age</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，定义了一个接口<code>Person</code>，它指定一个对象模板，拥有三个属性<code>firstName</code>、<code>lastName</code>和<code>age</code>。任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型。</p>
<p>实现该接口很简单，只要指定它作为对象的类型即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span>:<span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">firstName</span><span class="o">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lastName</span><span class="o">:</span> <span class="s1">&#39;Smith&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">age</span>: <span class="kt">25</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面示例中，变量<code>p</code>的类型就是接口<code>Person</code>，所以必须符合<code>Person</code>指定的结构。</p>
<p>方括号运算符可以取出 interface 某个属性的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">Foo</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span> <span class="c1">// string
</span></span></span></code></pre></div><p>上面示例中，<code>Foo['a']</code>返回属性<code>a</code>的类型，所以类型<code>A</code>就是<code>string</code>。</p>
<p>interface 可以表示对象的各种语法，它的成员有5种形式。</p>
<ul>
<li>对象属性</li>
<li>对象的属性索引</li>
<li>对象方法</li>
<li>函数</li>
<li>构造函数</li>
</ul>
<p>（1）对象属性</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>x</code>和<code>y</code>都是对象的属性，分别使用冒号指定每个属性的类型。</p>
<p>属性之间使用分号或逗号分隔，最后一个属性结尾的分号或逗号可以省略。</p>
<p>如果属性是可选的，就在属性名后面加一个问号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x?</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果属性是只读的，需要加上<code>readonly</code>修饰符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">readonly</span> <span class="nx">a</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>（2）对象的属性索引</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>[prop: string]</code>就是属性的字符串索引，表示属性名只要是字符串，都符合类型要求。</p>
<p>属性索引共有<code>string</code>、<code>number</code>和<code>symbol</code>三种类型。</p>
<p>一个接口中，最多只能定义一个字符串索引。字符串索引会约束该类型中所有名字为字符串的属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">a</span>: <span class="kt">boolean</span><span class="p">;</span>      <span class="c1">// 编译错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，属性索引指定所有名称为字符串的属性，它们的属性值必须是数值（<code>number</code>）。属性<code>a</code>的值为布尔值就报错了。</p>
<p>属性的数值索引，其实是指定数组的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">number</span><span class="p">]</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>:<span class="kt">A</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
</span></span></code></pre></div><p>上面示例中，<code>[prop: number]</code>表示属性名的类型是数值，所以可以用数组对变量<code>obj</code>赋值。</p>
<p>同样的，一个接口中最多只能定义一个数值索引。数值索引会约束所有名称为数值的属性。</p>
<p>如果一个 interface 同时定义了字符串索引和数值索引，那么数值索引必须服从于字符串索引。因为在 JavaScript 中，数值属性名最终是自动转换成字符串属性名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">number</span><span class="p">]</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">prop</span>: <span class="kt">number</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span> <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，数值索引的属性值类型与字符串索引不一致，就会报错。数值索引必须兼容字符串索引的类型声明。</p>
<p>（3）对象的方法</p>
<p>对象的方法共有三种写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 写法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写法二
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写法三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="o">:</span> <span class="p">{</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>属性名可以采用表达式，所以下面的写法也是可以的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">f</span><span class="p">](</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>类型方法可以重载。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">()</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">()</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyFunc</span><span class="p">()</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyFunc</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">boolean</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyFunc</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyFunc</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x?</span>:<span class="kt">boolean</span><span class="o">|</span><span class="kt">string</span><span class="p">,</span> <span class="nx">y?</span>:<span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span><span class="kt">number</span><span class="o">|</span><span class="kr">boolean</span><span class="o">|</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;boolean&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">y</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;wrong parameters&#39;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span>:<span class="kt">A</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span>: <span class="kt">MyFunc</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，接口<code>A</code>的方法<code>f()</code>有函数重载，需要额外定义一个函数<code>MyFunc()</code>实现这个重载，然后部署接口<code>A</code>的对象<code>a</code>的属性<code>f</code>等于函数<code>MyFunc()</code>就可以了。</p>
<p>（4）函数</p>
<p>interface 也可以用来声明独立的函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Add</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">x</span>:<span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>:<span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">myAdd</span>:<span class="kt">Add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span></code></pre></div><p>上面示例中，接口<code>Add</code>声明了一个函数类型。</p>
<p>（5）构造函数</p>
<p>interface 内部可以使用<code>new</code>关键字，表示构造函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">ErrorConstructor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="p">(</span><span class="nx">message?</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nb">Error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，接口<code>ErrorConstructor</code>内部有<code>new</code>命令，表示它是一个构造函数。</p>
<p>TypeScript 里面，构造函数特指具有<code>constructor</code>属性的类，详见《Class》一章。</p>
<h2 id="interface-的继承">interface 的继承</h2>
<p>interface 可以继承其他类型，主要有下面几种情况。</p>
<h3 id="interface-继承-interface">interface 继承 interface</h3>
<p>interface 可以使用<code>extends</code>关键字，继承其他 interface。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Circle</span> <span class="kr">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">radius</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>Circle</code>继承了<code>Shape</code>，所以<code>Circle</code>其实有两个属性<code>name</code>和<code>radius</code>。这时，<code>Circle</code>是子接口，<code>Shape</code>是父接口。</p>
<p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性。</p>
<p>interface 允许多重继承。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Style</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">color</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Circle</span> <span class="kr">extends</span> <span class="nx">Style</span><span class="p">,</span> <span class="nx">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">radius</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>Circle</code>同时继承了<code>Style</code>和<code>Shape</code>，所以拥有三个属性<code>color</code>、<code>name</code>和<code>radius</code>。</p>
<p>多重接口继承，实际上相当于多个父接口的合并。</p>
<p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span>: <span class="kt">number</span><span class="p">;</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>Bar</code>继承了<code>Foo</code>，但是两者的同名属性<code>id</code>的类型不兼容，导致报错。</p>
<p>多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">Baz</span> <span class="kr">extends</span> <span class="nx">Foo</span><span class="p">,</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>Baz</code>同时继承了<code>Foo</code>和<code>Bar</code>，但是后两者的同名属性<code>id</code>有类型冲突，导致报错。</p>
<h3 id="interface-继承-type">interface 继承 type</h3>
<p>interface 可以继承<code>type</code>命令定义的对象类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Country</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">capital</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">CountryWithPop</span> <span class="kr">extends</span> <span class="nx">Country</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">population</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>CountryWithPop</code>继承了<code>type</code>命令定义的<code>Country</code>对象，并且新增了一个<code>population</code>属性。</p>
<p>注意，如果<code>type</code>命令定义的类型不是对象，interface 就无法继承。</p>
<h3 id="interface-继承-class">interface 继承 class</h3>
<p>interface 还可以继承 class，即继承该类的所有成员。关于 class 的详细解释，参见下一章。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span>:<span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">y</span><span class="p">()</span><span class="o">:</span><span class="kr">boolean</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">z</span>: <span class="kt">number</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>B</code>继承了<code>A</code>，因此<code>B</code>就具有属性<code>x</code>、<code>y()</code>和<code>z</code>。</p>
<p>实现<code>B</code>接口的对象就需要实现这些属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span>:<span class="kt">B</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span>: <span class="kt">function</span><span class="p">(){</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">z</span>: <span class="kt">123</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，对象<code>b</code>就实现了接口<code>B</code>，而接口<code>B</code>又继承了类<code>A</code>。</p>
<p>某些类拥有私有成员和保护成员，interface 可以继承这样的类，但是意义不大。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">private</span> <span class="nx">x</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">protected</span> <span class="nx">y</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">z</span>: <span class="kt">number</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">b</span>:<span class="kt">B</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">C</span> <span class="kr">implements</span> <span class="nx">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>A</code>有私有成员和保护成员，<code>B</code>继承了<code>A</code>，但无法用于对象，因为对象不能实现这些成员。这导致<code>B</code>只能用于其他 class，而这时其他 class 与<code>A</code>之间不构成父类和子类的关系，使得<code>x</code>与<code>y</code>无法部署。</p>
<h2 id="接口合并">接口合并</h2>
<p>多个同名接口会合并成一个接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Box</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">height</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">width</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Box</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，两个<code>Box</code>接口会合并成一个接口，同时有<code>height</code>、<code>width</code>和<code>length</code>三个属性。</p>
<p>这样的设计主要是为了兼容 JavaScript 的行为。JavaScript 开发者常常对全局对象或者外部库，添加自己的属性和方法。那么，只要使用 interface 给出这些自定义属性和方法的类型，就能自动跟原始的 interface 合并，使得扩展外部类型非常方便。</p>
<p>举例来说，Web 网页开发经常会对<code>windows</code>对象和<code>document</code>对象添加自定义属性，但是 TypeScript 会报错，因为原始定义没有这些属性。解决方法就是把自定义属性写成 interface，合并进原始定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span></code></pre></div><p>上面示例中，接口<code>Document</code>增加了一个自定义属性<code>foo</code>，从而就可以在<code>document</code>对象上使用自定义属性。</p>
<p>同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span>: <span class="kt">string</span><span class="p">;</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，接口<code>A</code>的属性<code>a</code>有两个类型声明，彼此是冲突的，导致报错。</p>
<p>同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Cloner</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Animal</span><span class="p">)</span><span class="o">:</span> <span class="nx">Animal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Cloner</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Sheep</span><span class="p">)</span><span class="o">:</span> <span class="nx">Sheep</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Cloner</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Dog</span><span class="p">)</span><span class="o">:</span> <span class="nx">Dog</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Cat</span><span class="p">)</span><span class="o">:</span> <span class="nx">Cat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">Cloner</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Dog</span><span class="p">)</span><span class="o">:</span> <span class="nx">Dog</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Cat</span><span class="p">)</span><span class="o">:</span> <span class="nx">Cat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Sheep</span><span class="p">)</span><span class="o">:</span> <span class="nx">Sheep</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">clone</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Animal</span><span class="p">)</span><span class="o">:</span> <span class="nx">Animal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>clone()</code>方法有不同的类型声明，会发生函数重载。这时，越靠后的定义，优先级越高，排在函数重载的越前面。比如，<code>clone(animal: Animal)</code>是最先出现的类型声明，就排在函数重载的最后，属于<code>clone()</code>函数最后匹配的类型。</p>
<p>这个规则有一个例外。同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>:<span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span>:<span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>f()</code>方法有一个类型声明的参数<code>x</code>是字面量类型，这个类型声明的优先级最高，会排在函数重载的最前面。</p>
<p>一个实际的例子是 Document 对象的<code>createElement()</code>方法，它会根据参数的不同，而生成不同的 HTML 节点对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span>: <span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="o">:</span> <span class="s2">&#34;div&#34;</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLDivElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="o">:</span> <span class="s2">&#34;span&#34;</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLSpanElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="o">:</span> <span class="s2">&#34;canvas&#34;</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLCanvasElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 等同于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="o">:</span> <span class="s2">&#34;canvas&#34;</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLCanvasElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="o">:</span> <span class="s2">&#34;div&#34;</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLDivElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="o">:</span> <span class="s2">&#34;span&#34;</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLSpanElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">HTMLElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span>: <span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，<code>createElement()</code>方法的函数重载，参数为字面量的类型声明会排到最前面，返回具体的 HTML 节点对象。类型越不具体的参数，排在越后面，返回通用的 HTML 节点对象。</p>
<p>如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Circle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">area</span>: <span class="kt">bigint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">area</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">s</span>: <span class="kt">Circle</span> <span class="o">|</span> <span class="nx">Rectangle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">area</span><span class="p">;</span>   <span class="c1">// bigint | number
</span></span></span></code></pre></div><p>上面示例中，接口<code>Circle</code>和<code>Rectangle</code>组成一个联合类型<code>Circle | Rectangle</code>。因此，这个联合类型的同名属性<code>area</code>，也是一个联合类型。本例中的<code>declare</code>命令表示变量<code>s</code>的具体定义，由其他脚本文件给出，详见《declare 命令》一章。</p>
<h2 id="interface-与-type-的异同">interface 与 type 的异同</h2>
<p><code>interface</code>命令与<code>type</code>命令作用类似，都可以表示对象类型。</p>
<p>很多对象类型既可以用 interface 表示，也可以用 type 表示。而且，两者往往可以换用，几乎所有的 interface 命令都可以改写为 type 命令。</p>
<p>它们的相似之处，首先表现在都能为对象类型起名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Country</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">capital</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Coutry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">capital</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例是<code>type</code>命令和<code>interface</code>命令，分别定义同一个类型。</p>
<p><code>class</code>命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用<code>type</code>或<code>interface</code>。</p>
<p>interface 与 type 的区别有下面几点。</p>
<p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p>
<p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p>
<p>继承的主要作用是添加属性，<code>type</code>定义的对象类型如果想要添加属性，只能使用<code>&amp;</code>运算符，重新定义一个类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Bear</span> <span class="o">=</span> <span class="nx">Animal</span> <span class="o">&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">honey</span>: <span class="kt">boolean</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，类型<code>Bear</code>在<code>Animal</code>的基础上添加了一个属性<code>honey</code>。</p>
<p>上例的<code>&amp;</code>运算符，表示同时具备两个类型的特征，因此可以起到两个对象类型合并的作用。</p>
<p>作为比较，<code>interface</code>添加属性，采用的是继承的写法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bear</span> <span class="kr">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">honey</span>: <span class="kt">boolean</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>继承时，type 和 interface 是可以换用的。interface 可以继承 type。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Foo</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span>: <span class="kt">number</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>type 也可以继承 interface。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Bar</span> <span class="o">=</span> <span class="nx">Foo</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span>:<span class="kt">number</span> <span class="p">};</span> <span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">bar</span>:<span class="kt">number</span> <span class="p">};</span> <span class="c1">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>type</code>两次定义了类型<code>A</code>，导致两行都会报错。</p>
<p>作为比较，<code>interface</code>则会自动合并。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span> <span class="nx">foo</span>:<span class="kt">number</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">A</span> <span class="p">{</span> <span class="nx">bar</span>:<span class="kt">number</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>:<span class="kt">A</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">1</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面示例中，<code>interface</code>把类型<code>A</code>的两个定义合并在一起。</p>
<p>这表明，interface 是开放的，可以添加属性，type 是封闭的，不能添加属性，只能定义新的 type。</p>
<p>（4）<code>interface</code>不能包含属性映射（mapping），<code>type</code>可以，详见《映射》一章。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">type</span> <span class="nx">PointCopy1</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="k">keyof</span> <span class="nx">Point</span><span class="p">]</span><span class="o">:</span> <span class="nx">Point</span><span class="p">[</span><span class="nx">Key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">PointCopy2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="k">keyof</span> <span class="nx">Point</span><span class="p">]</span><span class="o">:</span> <span class="nx">Point</span><span class="p">[</span><span class="nx">Key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>（5）<code>this</code>关键字只能用于<code>interface</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">add</span><span class="p">(</span><span class="nx">num</span>:<span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">type</span> <span class="nx">Foo</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">add</span><span class="p">(</span><span class="nx">num</span>:<span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面示例中，type 命令声明的方法<code>add()</code>，返回<code>this</code>就报错了。interface 命令没有这个问题。</p>
<p>下面是返回<code>this</code>的实际对象的例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Calculator</span> <span class="kr">implements</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">add</span><span class="p">(</span><span class="nx">num</span>:<span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="nx">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>（6）type 可以扩展原始数据类型，interface 不行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">type</span> <span class="nx">MyStr</span> <span class="o">=</span> <span class="kt">string</span> <span class="o">&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;new&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">MyStr</span> <span class="kr">extends</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;new&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面示例中，type 可以扩展原始数据类型 string，interface 就不行。</p>
<p>（7）<code>interface</code>无法表达某些复杂类型（比如交叉类型和联合类型），但是<code>type</code>可以。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">AorB</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">AorBwithName</span> <span class="o">=</span> <span class="nx">AorB</span> <span class="o">&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>: <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>上面示例中，类型<code>AorB</code>是一个联合类型，<code>AorBwithName</code>则是为<code>AorB</code>添加一个属性。这两种运算，<code>interface</code>都没法表达。</p>
<p>综上所述，如果有复杂的类型运算，那么没有其他选择只能使用<code>type</code>；一般情况下，<code>interface</code>灵活性比较高，便于扩充类型或自动合并，建议优先使用。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 0001-01-01</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://localhost:1313/posts/typescript-tutorial/interface/" data-title=""><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://localhost:1313/posts/typescript-tutorial/interface/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="http://localhost:1313/posts/typescript-tutorial/interface/" data-title=""><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://localhost:1313/posts/typescript-tutorial/interface/" data-title=""><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://localhost:1313/posts/typescript-tutorial/interface/" data-title=""><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/typescript-tutorial/intro/" class="prev" rel="prev" title=""><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i></a>
            <a href="/posts/typescript-tutorial/generics/" class="next" rel="next" title=""><i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.118.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Aphros</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
